# TableCheck

**Prototype for table availability check**

## Description and assumptations

[Database schema](./db_schema.png)

- Some data constraints in this prototype depending on Postgres.
- Timezones are ignored in this prototype
- Reservation time borders are inclusive
- No passed argument verification done except ones in changesets

### Structure

Main context module serves as interface and only delegetes public function
calls to either query either command modules.

There three contextes:

1. [Restaurants](./lib/table_check/restaurants.ex) -> to manage restaurant and it's tables
2. [Reservations](./lib/table_check/reservations.ex) -> to manage reservation on restaurant tables
3. [Tables](./lib/table_check/tables.ex) -> to query availability on restaurant tables

### Entities

#### Restaurant

Restaurant entity itself. Has unique autogenerated id and required name.
No business hours implemented in prototype.

#### Tables

Table entity. Has unique autogenerated id and required capacity and id of restaurant fields.

Table capacity is the number of people that can sit at this table. We assume that capacity can be only positive number.

We assume that tables in our system created by one and we
don't have general table inventory.

#### Guests

Entity represents required information about person who reserves a table: name, phone, email. Also specific guest is linked to specific restaurant. We assume guest uniqueness by restaurant and phone number.

#### Reservations

Entity represents table reservation for specific date and specific time. Has required date, start_at, end_at, table_id, guest_id fields. In prototype we don't
have any status associated with reservation.

Reservation uniqueness guaranteed by database exclusion constraint by table id and
reservation datetime range.

Also we don't have any checks on reservation time limit etc. (Can create reservations that are already passed)

## Up and running

1. Install erlang and elixir versions from [tool versions file](./.tool-versions).

2. Ensure your Postgres is running and accesable on `localhost:5432` with default creds (postgres, postgres)

3. Fetch deps:

```sh
mix deps.get
```

4. Create database, migrate it and seed data

```sh
mix ecto.reset
```

5. Start application with iex console:

```sh
iex -S mix
```

## Usage

1. Create restaurant:

```elixir
iex> {:ok, restaurant} = TableCheck.Restaurants.create_restaurant(%{
    name: "My best restaurant"
    })
```

2. Create table for restaurant:

```elixir
iex> {:ok, table} = TableCheck.Restaurants.create_table(%{capacity: 1, restaurant_id: restaurant.id})
```

3. Create reservation for restaurant table:

```elixir
iex> TableCheck.Reservations.create_reservations(%{
            start_at: ~N[2024-02-19 18:00:00],
            end_at: ~N[2024-02-19 22:00:00],
            table_id: table.id,
            guest: %{
                name: "my best guest",
                phone: "some_magic_phone",
                restaurant_id: restaurant.id
            }
    })
```

4. Check restaurant availability:

```elixir
    # all tables reserved:
    iex> [] = TableCheck.Tables.list_available_tables(%{
        restaurant_id: restaurant.id,
        min_datetime: ~N[2024-02-19 17:00:00],
        max_datetime: ~N[2024-02-19 19:00:00]
    })
    # there is available table
    iex> TableCheck.Tables.list_available_tables(%{
        restaurant_id: restaurant.id,
        min_datetime: ~N[2024-02-20 17:00:00],
        max_datetime: ~N[2024-02-20 19:00:00]
    })
```

For more usage docs please refer to contexts.

## Running tests

To run tests:

```sh
mix test
```

To run with cover:

```sh
mix test --cover
```
